import Pic from "./pic.jpg"
import Image from "next/image"

<Image src={Pic} alt="REST API vs GraphQL" className="rounded-lg mb-8" />

"Should I use REST or GraphQL?" This question comes up in every project kickoff. After building APIs serving millions of requests daily with both approaches, here's the honest answer: it depends on your use case. Let me show you exactly when to use each.

## The Quick Answer

**Use REST when:**
- Building simple CRUD applications
- You have clear, stable data requirements
- Caching is critical
- You want simplicity

**Use GraphQL when:**
- Mobile apps need flexible data fetching
- You have complex, nested data relationships
- Multiple clients need different data shapes
- You want to reduce API calls

## REST API: The Tried and True

### Simple Example

```javascript
// REST endpoints
GET    /api/users          // Get all users
GET    /api/users/123      // Get specific user
POST   /api/users          // Create user
PUT    /api/users/123      // Update user
DELETE /api/users/123      // Delete user

// Fetching a user with posts
GET /api/users/123         // Returns user
GET /api/users/123/posts   // Returns user's posts
GET /api/posts/456/comments // Returns post comments

// Problem: 3 API calls for related data
```

### Next.js API Route Example

```typescript
// app/api/users/[id]/route.ts
import { NextResponse } from 'next/server';

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  const user = await db.user.findUnique({
    where: { id: params.id }
  });
  
  if (!user) {
    return NextResponse.json(
      { error: 'User not found' },
      { status: 404 }
    );
  }
  
  return NextResponse.json(user);
}
```

### Pros of REST:
- ✅ Simple and well understood
- ✅ Easy to cache (HTTP caching works out of the box)
- ✅ Great tooling and debugging
- ✅ Works with any client
- ✅ Smaller learning curve

### Cons of REST:
- ❌ Over-fetching data (getting fields you don't need)
- ❌ Under-fetching data (multiple requests for related data)
- ❌ Version management challenges
- ❌ Documentation can get out of sync

## GraphQL: The Flexible Alternative

### Same Data, One Request

```graphql
# Single GraphQL query
query GetUserWithPosts {
  user(id: "123") {
    id
    name
    email
    posts {
      id
      title
      comments {
        id
        text
        author {
          name
        }
      }
    }
  }
}

# Returns exactly what you asked for in ONE request
```

### Next.js with GraphQL

```typescript
// app/api/graphql/route.ts
import { createYoga } from 'graphql-yoga';
import { schema } from '@/lib/graphql/schema';

const { handleRequest } = createYoga({
  schema,
  graphqlEndpoint: '/api/graphql',
  fetchAPI: { Response },
});

export { handleRequest as GET, handleRequest as POST };
```

```typescript
// lib/graphql/schema.ts
import { createSchema } from 'graphql-yoga';

export const schema = createSchema({
  typeDefs: `
    type User {
      id: ID!
      name: String!
      email: String!
      posts: [Post!]!
    }
    
    type Post {
      id: ID!
      title: String!
      content: String!
      author: User!
    }
    
    type Query {
      user(id: ID!): User
      users: [User!]!
    }
  `,
  resolvers: {
    Query: {
      user: async (_, { id }) => {
        return await db.user.findUnique({
          where: { id },
          include: { posts: true }
        });
      },
      users: async () => {
        return await db.user.findMany();
      }
    }
  }
});
```

### Pros of GraphQL:
- ✅ Get exactly the data you need
- ✅ One endpoint for everything
- ✅ Strong typing and validation
- ✅ Excellent for mobile apps
- ✅ Self-documenting

### Cons of GraphQL:
- ❌ Steeper learning curve
- ❌ Caching is more complex
- ❌ Can have N+1 query problems if not careful
- ❌ More server complexity
- ❌ Harder to rate limit

## Performance Comparison

### Mobile App Loading Dashboard

**REST Approach:**
```
Request 1: GET /api/user/profile        → 45ms
Request 2: GET /api/user/stats          → 52ms  
Request 3: GET /api/user/notifications  → 38ms
Request 4: GET /api/user/recent-orders  → 61ms

Total: 196ms + network latency for 4 requests
```

**GraphQL Approach:**
```
Request 1: POST /api/graphql
{
  user { profile, stats, notifications, recentOrders }
}
→ 78ms

Total: 78ms for 1 request
```

**Winner for mobile:** GraphQL (60% faster, especially on slow connections)

## Real-World Decision Matrix

### E-commerce Site
**Our Choice:** Next.js + REST
**Why:** 
- Simple CRUD operations
- Heavy caching needs
- SEO is critical
- Standard data shapes

### Social Media App
**Our Choice:** Next.js + GraphQL
**Why:**
- Complex nested relationships
- Mobile and web clients
- Different data needs per platform
- Real-time updates

### Internal Dashboard
**Our Choice:** React + REST
**Why:**
- No SEO needed
- Simple data requirements
- Team familiar with REST
- Quick to build

## Hybrid Approach: Best of Both Worlds

You don't have to choose just one! Here's a pattern we use:

```typescript
// REST for simple operations
GET  /api/products        // List products (cacheable)
POST /api/orders          // Create order (simple)

// GraphQL for complex queries
POST /api/graphql
query {
  dashboard {
    user { ... }
    analytics { ... }
    notifications { ... }
  }
}
```

## Common Mistakes to Avoid

### Mistake 1: Using GraphQL for Everything
```
Don't do this:
mutation {
  createUser(input: {...})  // GraphQL mutation
}

When this is simpler:
POST /api/users  // REST endpoint
```

### Mistake 2: Creating Too Many REST Endpoints
```
Don't do this:
GET /api/user-with-posts-and-comments-and-likes

Do this instead:
GraphQL query with exactly what you need
```

## Performance Tips

### REST Optimization:
```typescript
// app/api/users/route.ts
export async function GET(request: Request) {
  // Add caching headers
  return NextResponse.json(users, {
    headers: {
      'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400'
    }
  });
}
```

### GraphQL Optimization:
```typescript
// Use DataLoader to prevent N+1 queries
import DataLoader from 'dataloader';

const userLoader = new DataLoader(async (userIds) => {
  const users = await db.user.findMany({
    where: { id: { in: userIds } }
  });
  return userIds.map(id => users.find(u => u.id === id));
});

// In resolver
const user = await userLoader.load(userId); // Batched!
```

## The Verdict for 2025

**For most projects, start with REST.** It's simpler, faster to build, and easier to optimize. Add GraphQL when you have:
- Multiple client applications with different needs
- Complex data relationships
- Mobile apps where bandwidth matters
- Teams that can handle the added complexity

## Need Help Choosing?

We've built production APIs with both REST and GraphQL serving millions of users. Whether you need a simple REST API for your e-commerce store or a complex GraphQL setup for your SaaS platform, we can help you make the right choice and implement it correctly.

**Key Takeaways:**
- REST is simpler and easier to cache
- GraphQL is more flexible but more complex
- You can use both in the same application
- Choose based on your specific needs, not trends
- Next.js works great with both REST and GraphQL

Ready to build your API the right way? Let's discuss your project requirements.
